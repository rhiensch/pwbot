#include <algorithm>

#include "abstractbot.h"

AbstractBot::AbstractBot()
{
}

// My planets
Planets AbstractBot::myStrongestPlanets(uint number) const
{
    return strongestPlanets(currentTurnData->MyPlanets(), number);
}

Planets AbstractBot::myWeakestPlanets(uint number) const
{
    return weakestPlanets(currentTurnData->MyPlanets(), number);
}

// Neutral planets
Planets AbstractBot::neutralStrongestPlanets(uint number) const
{
    return strongestPlanets(currentTurnData->NeutralPlanets(), number);
}

Planets AbstractBot::neutralWeakestPlanets(uint number) const
{
    return weakestPlanets(currentTurnData->NeutralPlanets(), number);
}

// Opponents planets
Planets AbstractBot::enemyStrongestPlanets(uint number, int opponentID) const
{
    Planets enemyPlanets = planetsWithGivenOwner(currentTurnData->EnemyPlanets(), opponentID);
    return strongestPlanets(enemyPlanets, number);
}

Planets AbstractBot::enemyWeakestPlanets(uint number, int opponentID) const
{
    Planets enemyPlanets = planetsWithGivenOwner(currentTurnData->EnemyPlanets(), opponentID);
    return weakestPlanets(enemyPlanets, number);
}

Planets AbstractBot::planetsWithGivenOwner(const Planets& planets, int ownerID) const
{
    if (ownerID == -1) {
        return planets;
    }
    else {
        Planets selectedPlanets;
        selectedPlanets.clear();

        uint size = planets.size();
        for (uint i = 0; i < size; ++i) {
            if (planets.at(i).Owner() == ownerID) {
                selectedPlanets.push_back(planets.at(i));
            }
        }
        return selectedPlanets;
    }
}

Fleets AbstractBot::fleetsWithGivenOwner(const Fleets& fleets, int ownerID) const
{
    if (ownerID == -1) {
        return fleets;
    }
    else {
        Fleets selectedFleets;
        selectedFleets.clear();

        uint size = fleets.size();
        for (uint i = 0; i < size; ++i) {
            if (fleets.at(i).Owner() == ownerID) {
                selectedFleets.push_back(fleets.at(i));
            }
        }
        return selectedFleets;
    }
}

// Any planets
Planets AbstractBot::weakestPlanets(const Planets& planets, uint number)
{
    Planets weakestPlanets;
    weakestPlanets.clear();

    if (number == 1) {
        Planet weakestPlanet = planets.at(0);

        uint size = planets.size();
        for (uint i = 1; i < size; ++i) {
            if (planets.at(i).NumShips() < weakestPlanet.NumShips()) {
                weakestPlanet = planets.at(i);
            }
        }

        weakestPlanets.push_back(weakestPlanet);
    }
    else if (number != 0) {
        weakestPlanets.reserve(number);

        Planets sortedPlanets = planets;
        std::sort(sortedPlanets.begin(), sortedPlanets.end(), compareNumberOfShipsLT);

        if (number > sortedPlanets.size()) {
            number = planets.size();
        }
        for (uint i = 0; i < number; ++i) {
            weakestPlanets.push_back(sortedPlanets.at(i));
        }
    }

    return weakestPlanets;
}

Planets AbstractBot::strongestPlanets(const Planets& planets, uint number)
{

    Planets strongestPlanets;
    strongestPlanets.clear();

    if (number == 1) {
        Planet strongestPlanet = planets.at(0);

        uint size = planets.size();
        for (uint i = 1; i > size; ++i) {
            if (planets.at(i).NumShips() < strongestPlanet.NumShips()) {
                strongestPlanet = planets.at(i);
            }
        }

        strongestPlanets.push_back(strongestPlanet);
    }
    else if (number != 0) {
        strongestPlanets.reserve(number);

        Planets sortedPlanets = planets;
        std::sort(sortedPlanets.begin(), sortedPlanets.end(), compareNumberOfShipsGT);

        if (number > sortedPlanets.size()) {
            number = planets.size();
        }
        for (uint i = 0; i < number; ++i) {
            strongestPlanets.push_back(sortedPlanets.at(i));
        }
    }

    return strongestPlanets;
}

bool AbstractBot::compareNumberOfShipsLT(const Planet& planet1, const Planet& planet2)
{
    return (planet1.NumShips() < planet2.NumShips());
}

bool AbstractBot::compareNumberOfShipsGT(const Planet& planet1, const Planet& planet2)
{
    return (planet1.NumShips() > planet2.NumShips());
}

Planet AbstractBot::planetsFutureStatus(const Planet& planet, uint numberOfTurns) const
{
    Planet planetInFuture = planet;

    // All fleets heading to this planet
    Fleets thisPlanetFleets = fleetsGoingToPlanet(currentTurnData->Fleets(), planet);
    uint thisPlanetFleetsSize = thisPlanetFleets.size();

    for (uint turn = 1; turn <= numberOfTurns; ++turn) {
        // Account for planet's growth
        if (planetInFuture.Owner() != 0) {
            planetInFuture.NumShips(planetInFuture.NumShips() + planetInFuture.GrowthRate());
        }

        // First is ownerID, second is number of ships
        std::vector<std::pair<uint, uint> > ships;

        // Get all fleets whic will arrive at the planet in this turn
        Fleets thisTurnFleets;
        thisTurnFleets.clear();

        for (uint i = 0; i < thisPlanetFleetsSize; ++i) {
            if (thisPlanetFleets.at(i).TurnsRemaining() == turn) {
                thisTurnFleets.push_back(thisPlanetFleets.at(i));
            }
        }

        if (!thisTurnFleets.empty()) {
            uint owners = 2;
            for (uint id = 1; id < owners; ++id) {
                Fleets ownerFleets = fleetsWithGivenOwner(thisTurnFleets, id);
                std::pair<uint, uint> ownerShips;
                ownerShips.first = id;
                ownerShips.second = 0;

                // Add up fleets with the same owner
                uint ownerFleetsSize = ownerFleets.size();
                for (uint i = 0; i < ownerFleetsSize; ++i) {
                    ownerShips.second += ownerFleets.at(i).NumShips();
                }

                // Add the ships from the planet to the corresponding fleet
                if (planetInFuture.Owner() == id) {
                    ownerShips.second += planetInFuture.NumShips();
                }

                ships.push_back(ownerShips);
            }

            // If the planet was neutral, it has it's own fleet
            if (planetInFuture.Owner() == 0) {
                std::pair<uint, uint> ownerShips;
                ownerShips.first = 0;
                ownerShips.second = planetInFuture.NumShips();

                ships.push_back(ownerShips);
            }

            uint shipsSize = ships.size();

            // Were there any fleets other than the on on the planet?
            if (shipsSize > 1) {
                // Sorts the fleets in descending order by the number of ships in the fleet
                std::sort(ships.begin(), ships.end(), compareSecondOfPair<uint, uint>);

                std::pair<uint, uint> winner = ships.at(0);
                std::pair<uint, uint> secondToWinner = ships.at(1);

                if (winner.second == secondToWinner.second) {
                    planetInFuture.Owner(0);
                    planetInFuture.NumShips(0);
                }
                else {
                    planetInFuture.Owner(winner.first);
                    planetInFuture.NumShips(winner.second - secondToWinner.second);
                }
            }
        }
    }

    return planetInFuture;
}

template <typename T1, typename T2>
bool AbstractBot::compareSecondOfPair(const std::pair<T1, T2>& pair1, const std::pair<T1, T2>& pair2)
{
    return (pair1.second > pair2.second);
}

Planets AbstractBot::myEndangeredPlanets(uint numberOfTurns, uint treshold) const
{
    Planets planets = currentTurnData->MyPlanets();
    Planets endangeredPlanets;
    endangeredPlanets.clear();

    uint size = planets.size();
    for (uint i = 0; i < size; ++i) {
        Planet planetInFuture = planetsFutureStatus(planets.at(i), numberOfTurns);
        if (planetInFuture.Owner() != 1 || planetInFuture.NumShips() <= treshold) {
            endangeredPlanets.push_back(planets.at(i));
        }
    }

    return endangeredPlanets;
}

Planets AbstractBot::myPlanetsUnderAttack() const
{
    Fleets enemyFleets = currentTurnData->EnemyFleets();
    Planets attackedPlanets;
    attackedPlanets.clear();

    uint size = enemyFleets.size();
    for (uint i = 0; i < size; ++i) {
        Planet planet = currentTurnData->GetPlanet(enemyFleets.at(i).DestinationPlanet());
        if (planet.Owner() == 1) {
            attackedPlanets.push_back(planet);
        }
    }

    return attackedPlanets;
}

Planets AbstractBot::neutralPlanetsUnderAttack() const
{
    Fleets enemyFleets = currentTurnData->EnemyFleets();
    Planets attackedPlanets;
    attackedPlanets.clear();

    uint size = enemyFleets.size();
    for (uint i = 0; i < size; ++i) {
        Planet planet = currentTurnData->GetPlanet(enemyFleets.at(i).DestinationPlanet());
        if (planet.Owner() == 0) {
            attackedPlanets.push_back(planet);
        }
    }

    return attackedPlanets;
}

Fleets AbstractBot::myFleetsGoingToPlanet(const Planet& planet) const
{
    return fleetsGoingToPlanet(currentTurnData->MyFleets(), planet);
}

Fleets AbstractBot::enemyFleetsGoingToPlanet(const Planet& planet, int opponentID) const
{
    return fleetsGoingToPlanet(fleetsWithGivenOwner(currentTurnData->EnemyFleets(), opponentID), planet);
}

Fleets AbstractBot::fleetsGoingToPlanet(const Fleets& fleets, const Planet& planet) const
{
    Fleets attackingFleets;
    attackingFleets.clear();

    uint size = fleets.size();
    for (uint i = 0; i < size; ++i) {
        if (fleets.at(i).DestinationPlanet() == planet.PlanetID()) {
            attackingFleets.push_back(fleets.at(i));
        }
    }

    return attackingFleets;
}

Planets AbstractBot::myPlanetsWithinProximityToPlanet(const Planet& planet, uint proximityTreshold) const
{
    return planetsWithinProximityToPlanet(currentTurnData->MyPlanets(), planet, proximityTreshold);
}

Planets AbstractBot::neutralPlanetsWithinProximityToPlanet(const Planet& planet, uint proximityTreshold) const
{
    return planetsWithinProximityToPlanet(currentTurnData->NeutralPlanets(), planet, proximityTreshold);
}

Planets AbstractBot::enemyPlanetsWithinProximityToPlanet(const Planet& planet, uint proximityTreshold, int opponentID) const
{
    return planetsWithinProximityToPlanet(planetsWithGivenOwner(currentTurnData->EnemyPlanets(), opponentID), planet, proximityTreshold);
}

Planets AbstractBot::planetsWithinProximityToPlanet(const Planets& planets, const Planet& planet, uint proximityTreshold) const
{
    Planets nearbyPlanets;
    nearbyPlanets.clear();

    uint size = planets.size();
    for (uint i = 0; i < size; ++i) {
        uint distance = currentTurnData->Distance(planets.at(i).PlanetID(), planet.PlanetID());
        if (distance <= proximityTreshold) {
            nearbyPlanets.push_back(planets.at(i));
        }
    }

    return nearbyPlanets;
}

bool AbstractBot::isPlanetUnderAttack(const Planet& planet)
{
    Fleets fleets = currentTurnData->Fleets();

    uint size = fleets.size();
    for (uint i = 0; i < size; ++i) {
        if (fleets.at(i).DestinationPlanet() == planet.PlanetID()) {
            return true;
        }
    }

    return false;
}
